{"title": "Regular Repair of Specifications.", "fields": ["edit distance", "regular language", "computational complexity theory", "formal specification", "temporal logic"], "abstract": "What do you do if a computational object (e.g. program trace) fails a specification?An obvious approach is to perform \\emph{repair}: modify the object minimally to get something that satisfies the constraints..In this paper we study repair of temporal constraints, given as automata or temporal logic formulas. We focus on determining the number of repairs that must be applied to a word satisfying a given input constraint in order to ensure that it satisfies a given target constraint. This number may well be unbounded, one of our main contributions is to isolate the complexity of the ``bounded repair problem'', based on a characterization of the pairs of regular languages that admit such a repair. Weconsider this in the setting where the repair strategy is unconstrained and also when the strategy is restricted to use finite memory. Although the streaming setting is quite different from the general setting, we find that there are surprising connections between streaming and non-streaming, as well as within variants of the streaming problem.", "citation": "Citations (12)", "departments": ["University of Oxford", "University of Oxford", "University of Oxford"], "authors": ["Michael Benedikt.....http://dblp.org/pers/hd/b/Benedikt:Michael", "Gabriele Puppis.....http://dblp.org/pers/hd/p/Puppis:Gabriele", "Cristian Riveros.....http://dblp.org/pers/hd/r/Riveros:Cristian"], "conf": "lics", "year": "2011", "pages": 10}