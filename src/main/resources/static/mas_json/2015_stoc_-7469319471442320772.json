{"title": "Succinct Randomized Encodings and their Applications.", "fields": ["key derivation function", "plaintext", "randomness", "functional encryption", "computation"], "abstract": "A  randomized encoding  allows to express a \"complex\" computation, given by a function f and input x, by a \"simple to compute\" randomized representation f(x) whose distribution encodes f(x), while revealing nothing else regarding f and x. Existing randomized encodings, geared mostly to allow encoding with low parallel-complexity, have proven instrumental in various strong applications such as multiparty computation and parallel cryptography. This work focuses on another natural complexity measure:  the time required to encode . We construct  succinct randomized encodings  where the time to encode a computation, given by a program \u03a0 and input x, is essentially independent of \u03a0's time complexity, and only depends on its space complexity, as well as the size of its input, output, and description. The scheme guarantees computational privacy of (\u03a0,x), and is based on indistinguishability obfuscation for a relatively simple circuit class, for which there exist instantiations based on polynomial hardness assumptions on multi-linear maps.   We then invoke succinct randomized encodings to obtain several strong applications, including: Succinct indistinguishability obfuscation, where the obfuscated program IObf({\u03a0}) computes the same function as \u03a0 for inputs x of apriori-bounded size. Obfuscating \u03a0 is roughly as fast as encoding the computation of \u03a0 on any such input x. Here we also require subexponentially-secure indistinguishability obfuscation for circuits. Succinct functional encryption, where a functional decryption key corresponding to \u03a0 allows decrypting \u03a0(x) from encryptions of any plaintext x of apriori-bounded size. Key derivation is as fast as encoding the corresponding computation. Succinct reusable garbling, a stronger form of randomized encodings where any number of inputs x can be encoded separately of \u03a0, independently of \u03a0's time and space complexity. Publicly-verifiable 2-message delegation where verifying the result of a long computation given by \u03a0 and input x is as fast as encoding the corresponding computation. We also show how to transform any 2-message delegation scheme to an essentially non-interactive system where the verifier message is reusable.   Previously, succinct randomized encodings or any of the above applications were only known based on various non-standard knowledge assumptions.   At the heart of our techniques is a generic method of compressing a piecemeal garbled computation, without revealing anything about the secret randomness utilized for garbling.", "citation": "Not cited", "year": "2015", "departments": ["Massachusetts Institute of Technology", "University of California, Berkeley", "University of California, Santa Barbara", "Cornell University", "Cornell University"], "conf": "stoc", "authors": ["Nir Bitansky.....http://dblp.org/pers/hd/b/Bitansky:Nir", "Sanjam Garg.....http://dblp.org/pers/hd/g/Garg:Sanjam", "Huijia Lin.....http://dblp.org/pers/hd/l/Lin:Huijia", "Rafael Pass.....http://dblp.org/pers/hd/p/Pass:Rafael", "Sidharth Telang.....http://dblp.org/pers/hd/t/Telang:Sidharth"], "pages": 10}