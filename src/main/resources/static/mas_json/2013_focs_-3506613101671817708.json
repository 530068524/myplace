{"title": "How to Approximate a Set without Knowing Its Size in Advance.", "fields": ["data structure", "false positive rate", "amortized analysis", "log log plot", "bloom filter"], "abstract": "The dynamic approximate membership problem asks to represent a set S of size n, whose elements are provided in an on-line fashion, supporting membership queries without false negatives and with a false positive rate at most e. That is, the membership algorithm must be correct on each x \u2208 S, and may err with probability at most e on each x \u2209 S. We study a well-motivated, yet insufficiently explored, variant of this problem where the size n of the set is not known in advance. Existing optimal approximate membership data structures require that the size is known in advance, but in many practical scenarios this is not a realistic assumption. Moreover, even if the eventual size n of the set is known in advance, it is desirable to have the smallest possible space usage also when the current number of inserted elements is smaller than n. Our contribution consists of the following results: (1) We show a super-linear gap between the space complexity when the size is known in advance and the space complexity when the size is not known in advance. When the size is known in advance, it is well-known that \u0398(n log(1/e)) bits of space are necessary and sufficient (Bloom '70, Carter et al. '78). However, when the size is not known in advance, we prove that at least (1 -o(1))n log(1/e)+\u03a9(n log log n) bits of space must be used. In particular, the average number of bits per element must depend on the size of the set. . We show that our space lower bound is tight, and can even be matched by a highly efficient data structure. We present a data structure that uses (1+o(1))n log(1/e)+O(n log log n) bits of space for approximating any set of any size n, without having to know n in advance. Our data structure supports membership queries in constant time in the worst case with high probability, and supports insertions in expected amortized constant time. Moreover, it can be \u201cde-amortized\u201d to support also insertions in constant time in the worst case with high probability by only increasing its space usage to O(n log(1/e) + n loglogn) bits.", "citation": "Citations (5)", "year": "2013", "departments": ["IT University of Copenhagen", "Stanford University", "Microsoft"], "conf": "focs", "authors": ["Rasmus Pagh.....http://dblp.org/pers/hd/p/Pagh:Rasmus", "Gil Segev.....http://dblp.org/pers/hd/s/Segev:Gil", "Udi Wieder.....http://dblp.org/pers/hd/w/Wieder:Udi"], "pages": 10}