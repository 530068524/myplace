{"title": "Dynamic Integer Sets with Optimal Rank, Select, and Predecessor Search.", "fields": ["small set", "integer", "binary logarithm", "log log plot", "polynomial"], "abstract": "We present a data structure representing a dynamic set S of w-bit integers on a w-bit word RAM. With |S| = n and w \u2265 log n and space O(n), we support the following standard operations in O(log n/log w) time: insert(x) sets S = S + {x}. delete(x) sets S = S {x}. predecessor(x) returns max{y \u2208 S | y < x}. rank(x) returns #{y \u2208 S | y < x}. select (i) returns y \u2208 S with rank (y) = i, if any. Our O(log n/log w) bound is optimal for dynamic rank and select, matching a lower bound of Fredman and Saks [STOC'89]. When the word length is large, our time bound is also optimal for dynamic predecessor, matching a static lower bound of Beame and Fich [STOC'99] whenever log n/log w = O(log w/log log w). Technically, the most interesting aspect of our data structure is that it supports all the above operations in constant time for sets of size n = w O(1). This resolves a main open problem of Ajtai, Komlos, and Fredman [FOCS\u0081f83]. Ajtai et al. presented such a data structure in Yao\u0081fs abstract cell-probe model with w-bit cells/words, but pointed out that the functions used could not be implemented. As a partial solution to the problem, Fredman and Willard [STOC\u0081f90] introduced a fusion node that could handle queries in constant time, but used polynomial time on the updates. We call our small set data structure a dynamic fusion node as it does both queries and updates in constant time.", "citation": "Citations (12)", "departments": ["AT&T", "University of Copenhagen"], "authors": ["Mihai Patrascu.....http://dblp.org/pers/hd/p/Patrascu:Mihai", "Mikkel Thorup.....http://dblp.org/pers/hd/t/Thorup:Mikkel"], "conf": "focs", "year": "2014", "pages": 10}